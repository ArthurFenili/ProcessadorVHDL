ADDI
opcode: 1000
formato da instrução:
XXXX YYY ZZZZZZZZZ
opcode | registrador de destino | constante

JMP
opcode: 1111
formato da instrução:
XXXX ----- YYYYYYY
opcode | ----- | endereço do deslocamento

MOVE
opcode: 0100
formato da instrução:
XXXX YYY ZZZ ------
opcode | registrador de destino | registrador de origem | ------
MOVE.sz <ea>y,<ea>x

ADD
opcode: 0001
formato da instrução:
XXXX YYY ZZZ WWW ---
opcode | registrador de destino | registrador de origem | ------
ADD.L <ea>y,Dx

SUB
opcode: 0010
formato da instrução:
XXXX YYY ZZZ WWW ---
opcode | registrador de destino | registrador de origem | ------
SUB.L <ea>y,Dx

NOP
opcode: 0000
formato da instrução:
XXXX ------------
opcode | ---------------

BLT
opcode (branch): 0110
opcode (less than): 1101
teste de flag: N & ~V | ~N & V
formato da instrução:
XXXX YYYY ZZZZZZZZ
opcode(branch) | opcode(LT) | endereços de pulo

BGE
opcode (branch): 0110
opcode (greater or equal): 1100
teste de flag: N & V | ~N & ~V
formato da instrução:
XXXX YYYY ZZZZZZZZ
opcode(branch) | opcode(GE) | endereços de pulo



tem o opcode geral pra saber que é um branch

aí tem a condition que é o opcode de cada um dos branches

vamos verificar o opcode geral, se for branch ja passa o endereço (8 ultimos bits) pro endereço de jump
aí verifica a condition qual é e faz as operações com as flags, se as operações derem true, ativa o jump_en

criar uma entrada no PCUC de end_branch que vai receber o deslocamento da isntrução e se o jump en for true,
soma o deslocamento com o d_out do PCUC